Performance

We benchmark the performance of our own variants of the Union-Find decoder, as well as the Union-Find Node-Suspension (UFNS) decoder of Algorithm X. Decoding rate d for a given lattice size L and physical error rate are acquired by Monte Carlo simulations. We apply the error model of only i.i.d. bit-flip errors with chance X, which is independent noise. Additionally, we compare the performance for phenomenological noise, which adds faulty syndrome measurements occurring at chance X. Code thresholds X are obtained by curve fitting for the crossing point of decoding rates plotted in X space, for a range of values for L and X [0]. We also use the decoding rate at the threshold X as a metric to compare decoders. 

Union-Find decoder variants

First, we show that X can be increased and the matching weight X can be decreased within the Union-Find decoder without the Node-Suspension data structure. We compare distinct variants of our implementation of the Union-Find decoder, that either implements Weighted Growth via bucket sort or no Weighted Growth, and either constructs a forest F of grown clusters post-growth, which is the case in the original Union-Find decoder, or maintains acyclic vertex-trees X during cluster growth. The latter is achieved by applying lines X-X of Algorithm X in the UF decoder. The labels used for each variant are listed in X. The full descriptions for each of the variants can be found in [0].


\Figure[b!](topskip=0pt, botskip=0pt, midskip=0pt)tikzfigs/comp_matching_weight.pdf{
  The matching weight X of the Union-Find decoder variants (Table X) and the UFNS decoder, normalized to the minimum weight X of the Minimum-Weight Perfect Matching decoder. All weights are obtained by Monte Carlo simulations on X with a minimum of 100.000 samples. The x-axis scales linearly with X. 

\Figure[htb](topskip=0pt, botskip=0pt, midskip=0pt)tikzfigs/threshold_ufbb.pdf{
  The decoding rates d of (a) the UFNS decoder and (c) the bvUF and MWPM decoders, obtained via Monte Carlo simulations with a minimum of 100.000 samples per lattice size per error rate. (a) The d lines of the UFNS decoder do not cross in a single point, such that there is not obvious code threshold. (b) The crossing point of d lines of subsequent lattice sizes are the so-called threshold coordinates, which follow a trend in X space as the lattice sizes increase. (c) The threshold coordinates of the UFNS decoder occupy the region in X space of the MWPM decoder. 

The values for X and X for each variant, including for the Minimum-Weight Perfect Matching (MWPM) decoder, are listed in X. Weighted Growth has the expected behavior of increasing X. While there is no major increase in X from the X-variants over the F-variants, a significant increase in X can be observed. We suspect that the acyclic graphs of X has shorter branches in between junctions compared to F, which leads to a deceased matching weight and increased X. We plot the matching weight X of the UF variants, normalized to the minimum weight of the MWPM decoder for X in X. Here we see a correlation between a decrease in X with an increase in performance: both Weighted Growth and maintaining X during growth increases the performance and decreases the matching weight. Furthermore, the matching weight in X-variants have a relatively low and constant factor over the minimum weight, which improves upon the L-dependent behavior of F-variants 


Union-Find Node-Suspension decoder
We benchmark the performance of the Union-Find Node-Suspension (UFNS) decoder of Algorithm X, and plot the decoding rates in Xa per lattice size. We discover that the curves related to the decoding rates do not cross in a single point, such that there is no clear threshold X. In fact, the intersections of two curves of subsequent lattices sizes, which we dub threshold coordinates, follow a trend where an increase in the input lattice sizes results in a decrease in X but increase in X. We ascribe the degradation of the threshold error rate to the Parity Inversion effect. These threshold coordinates X are plotted in Xb. When these coordinates are plotted together with the decoding rates of the bvUF and MWPM decoders, such as in Xc, we see that the threshold coordinate for small lattice sizes is similar to the MWPM threshold coordinate. For larger lattice sizes, UFNS threshold coordinates move towards the bvUF threshold on the X axis, but still has an increased performance due on the increased X. Overall, the threshold coordinates occupy a region in X space that was previously reserved to the MWPM decoder. 

\Figure[b!](topskip=0pt, botskip=0pt, midskip=0pt)tikzfigs/comp_time.pdf{
  The mean computation time of the UFNS, bvUF and MWPM decoders near the threshold error rate. All weights are obtained by Monte Carlo simulations for X with a minimum of 100.000 samples. The x-axis scales linearly with X.

The matching weight X of the UFNS decoder is successfully decreased compared to all UF variants of X. For X the normalized matching weight is halved compared to the bvUF decoder (X). We compare the average running time of Monte Carlo simulations to obtain a matching between the UFNS, bvUF and MWPM decoders. A comparison for a physical error rate near the threshold is included in X. The average running time of UFNS, while not behaving according to worst-case X, is also not linear. 

\Figure[tbh](topskip=0pt, botskip=0pt, midskip=0pt)tikzfigs/comp_lowerror.pdf{
  The decoding rate d for the low error regime of phenomenological noise for the MWPM, UFNS and bvUF decoders. The UFNS decoding rates are improved from the UF variants, and is very similar to MWPM. All d are obtained by Monte Carlo simulations with a minimum of 100.000 samples. The x-axis scales linearly with X.

Finally, we show in X the performance of the UFNS decoder in the low error regime with phenomenological noise. The decoding rate of the UFNS decoder is improved from the bvUF decoder and behaves similarly to the MWPM decoder. The mean computation time of the decoders in this regime, plotted in X, shows that the UFNS decoder performs at about the same speed as the bvUF decoder.

The simulator for the surface code, the Union-Find decoder variants and the Union-Find Node-Suspension decoder have all been implemented in Python using our application [0]. The MWPM decoder utilizes the C implementation of BlossomV [0] due to substantial slow performances of Python implementations. Simulations were initially performed on a single 3.20 GHz Intel Core i5 CPU, but later parallelized on all 24 threads of 3.60 GHz Intel Xeon E5 CPU's. 
