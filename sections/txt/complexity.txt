
Complexity of Node-Suspension

In this section, we will find the worst-cast time complexity of the Union-Find Node-Suspension decoder. The addition cost of the original Union-Find decoder can be split in two parts: (A) the depth-first-searches (DFS's) related to the (re)calculation of the node parities and node delays in line X, and (B) the DFS related to the growth of a cluster in line X. We dub the two parts the suspension cost and the growth cost, respectively. The Join operation in lines X-X only has a linear addition to the cost.

Suspension cost

The cost of node suspension calculation is proportional to X, the number of nodes traversed in the DFS's of the node parities and node delays. As a result of Odd-Rooted Join, X is proportional to the sum of sizes of all even node-trees. Root List Replacement decreases the sum to the most recent even node-trees that are ancestors of grown odd node-trees, which we dub X node-trees. To find the worst-case time complexity, we maximize X, which is proportional to the computation time. We take a time-reversed approach of analyzing a cluster; starting from a single cluster that maximally occupies the lattice at the end of growth, and move back in time to find its ancestor clusters. In this process that we call cluster fragmentation, we aim to find the set of cluster mergers that maximizes the number and sizes of X node-trees. 





definition
  Let the fragmentation function f on an odd node-tree X return the set of X of its most recent odd ancestor node-trees on which suspension calculations were performed. Let the prefix on the node-tree indicate the fragmentation generation, such that X returns X node-trees of generation k, denoted by X:
  Let f be the combination of partial fragmentation functions X and X, where X fragments an odd node-tree X into an odd ancestor X and an even ancestor node-tree X: 
  and where X further fragments X into X odd ancestors

definition

The fragmentation function can be applied consecutively, such that a set of odd node-trees of generation k is fragmented to ancestors of generation X. We use the notation X to indicate that two fragmentations are applied on X to obtain ancestors of generation X. Furthermore, let X and be equivalent to X. 

According to Odd-Rooted Join and Root List Replacement, if the cluster of node-tree X is grown, the DFS's of the parity and delay calculations are performed within X. Therefore, every even node-tree returned by X is a X node-tree. The value of X can thus be obtained by taking the sum of sizes of all even node-tree in X over a series of X fragmentations of some odd node-tree X until there are no more ancestor node-trees:

To find X, we are going to make two assumptions to simplify X. Junction-nodes are initiated on the tangent of two node radii belonging to separate node-trees when merging into one. For increasing fragmentation generation, the total number of nodes in the fragmented set must therefore decrease. By neglecting their existence, X becomes
Furthermore, if only syndrome-nodes exist, the size of X must equal the sum of sizes of its ancestors X. In other words, the size of the ancestor X can be represented by the fragmentation ratio
Secondly, we assume that vertex-trees do not increase in size, such that X. Normally, the number of nodes in a cluster is bounded by the number of vertices X, as non-trivial vertices can be added to the node, which increase the node radius. By this assumption, the vertex-tree can only increase in size as the result of a merger between clusters, and nodes are effectively not allowed to increase in radius. While this is not possible in during realistic cluster growth, using this assumption simplifies X, as we will see later, while not compromising its upper bound. 

To find the upper bound in X, we are now tasked to find: (a) X, the number of ancestors in X; (b) the fragmentation ratios X; and (c) the number of fragmentation generations X. 

lemma
  For constant fragmentation ratios X, the sum X is constant for every k. 
lemma
proof
  For X, there is a single even ancestor X of size 
  For X, every odd node-tree in X is fragmented by X to an even ancestor X for X, such that 
  The same is true for all subsequent generations k. 
proof

theorem
  Upper bound for X is obtained by setting X in X. 
theorem
proof
  The sum of even node-tree sizes in every generation is constant per X. Thus, upper bound in X is obtained by the largest possible X. As X increases the number of odd node-trees in each X, the average size of these odd node-trees decreases. Since the size of a node-tree is proportional to the number of ancestor generations, we find that 
  Hence, the upper bound in X exists in the minimal value of X, which is X.
proof

Using X, we now find that a fragmentation on an odd cluster X returns X, where X are ancestors of the even node-tree X returned by X. 

lemma
  The node-tree size of X must be smaller than X, such that X. 
lemma
proof
  The partial fragmentations must occur in the order of first X, then X, as X requires an even node-tree that is returned by X. In terms of cluster growth, the vertex-trees X, corresponding to X, must merge before the combined vertex-tree can merge with X, which corresponds to X. Declared by Weighted Growth, X and X must be smaller or equal to X, such that 
  If this condition is not met, the cluster of X grows first and merges with either X or X, and the chronology of events is disturbed. Since we assumed X, this can be translated to 
  and subsequently to the fragmentation ratios.
proof

theorem
  Upper bound for X is obtained via the fragmentation ratios X.
theorem
proof
  The ratios X can be found by maximizing the size of the even node-tree X in each fragmentation, which is 
  Since X per X, the largest values for X possible are equal to X.
proof

The last unknown parameter in finding the upper bound of X in Equation X is X.

theorem
  For X and X, the maximum number of fragmentation generations is X.
theorem
proof
  In every generation, all node-trees are fragmented into 3 ancestors that are X the size of their descendant. The series of X fragmentations is thus simply X divisions of the node-tree X in 3 parts until all ancestors have size 1, at which point a node-tree cannot be fragmented.
proof

Collecting X and filling in Equation X we find that


The maximum size of the odd node-tree X is bounded by the system size X. The worst-case time complexity of the suspension calculation is thus X. 

Growth cost

To grow a cluster represented by a node-tree X, a depth-first search (DFS) is performed on the node-tree to find all nodes that have zero suspension. The total cost of these DFS's are proportional to the total number of nodes encountered during these DFS's, which we dub X. Using the definition of fragmentations of X, the cost of growth is proportional to
We assume again that no trivial vertices are added  to a cluster or X such that X becomes an upper bound. As a result of Odd-Rooted Join and Root List Replacement, the upper bound is obtained if there are as many fragmentation generations. This is again achieved through X. For every fragmentation of some odd node-tree X into X, all three ancestors add to X if they have grown. According to Weighted Growth, this is the case when X such that X. For these values of X and R, we can apply X for X. For X, the sum of node-tree sizes in every fragmented set X is exactly X, and we find that
which again corresponds to a worst-case time complexity X.
