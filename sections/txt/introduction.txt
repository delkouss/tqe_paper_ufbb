Introduction
One of the most promising approaches for fault-tolerant quantum computation is based on surface quantum error correcting codes [0]. With surface codes, error correction only requires the measurement of local operators on a 2-dimensional lattice of qubits. The measurement outcome, called the syndrome, is passed to the decoding algorithm to deduct the error that has occurred and to supply a correction operator. The resilience against errors can be improved by increasing the system size whilst the physical error rate is below a threshold value X. For this, it is essential that the decoder has low time complexity; if the clock-rate of the quantum computer becomes limited by the decoder, the advantages of increasing the system size could be compromised.

Many decoding algorithms have been developed that either aim to improve the threshold and lower logical error rates wang2003confinement, raussendorf2007faulttolerant, fowler2012towards, fowler2013minimum, heim2016optimal, duclos2010fast, duclos2013fault, bravyi2014efficient, darmawan2018linear, or to perform under more realistic noise models tuckett2020fault, hutter2015improved, bravyi2013quantum,  nickerson2019analysing, wootton2012high, huang2020fault, including a new class of neural network decoders baireuther2019neural, chamberland2018deep, liu2019neural, nautrup2019optimizing, torlai2017neural, varsamopoulos2017decoding, varsamopoulos2020decoding, and other types bombin2012universal, herold2015cellular, horsman2012surface, kubica2019cellular, watson2015fast. Identifying the optimal decoder of the code depends critically on the noise model. The most popular decoder for surface codes is unarguably still the Minimum-Weight Perfect Matching (MWPM) decoder. It performs near optimal for a bit-flip noise model [0] on a standard non-bounded surface code with a threshold of X, and for a phenomelogical noise model including faulty measurements [0] with X . The basic principle behind this approach is to identify the lowest weight error configuration that can produce the syndrome. The minimum-weight matchings are found by constructing a fully connected graph between nodes of the syndrome, which leads to a cubic worst-case time complexity of X, where n is the number of qubits in the system [0]. Fowler has proved that the matching problem can be solved in average X time, but only at sufficiently low error rates, and the worst-case complexity remains significant [0]. 

In this work, we build on top of a recently proposed decoder called the Union-Find (UF) decoder. It combines a very low worst-case time complexity with a high threshold delfosse2017almost making it a practical solution for real devices. The thresholds of the UF decoder on the toric code with bit-flip noise and phenomenological noise are X and X, and its worst-case time complexity is X, where X is the inverse of Ackermann's function [0]. For any physical feasible amount of qubits, this value is X, leading to an ``almost-linear'' time complexity.

We propose here a modification of the UF decoder that improves the heuristic for minimum-weight matching. The modified decoder, which we dub the Union-Find Node-Suspension decoder (UFNS), achieves near MWPM performance while retaining a quasilinear time complexity. In sections X and X we introduce the surface code and the UF decoder. In section X we describe the modified algorithm and its motivation. We discuss the complexity of the algorithm in section X and compare its performance with other decoders in section X.  

The Surface Code

The Union-Find Node-Suspension decoder proposed here, similarly to its parent decoder, is applicable to any surface code of any genus, with or without boundary, and to color codes [0]. For simplicity, we only describe the standard implementation of the surface code without boundary.

The toric code, a topological code introduced by Kitaev [0], is defined by arranging qubits on the edges of a square lattice with periodic boundary conditions. The code is denoted by V,E,F, respectively the set of vertices, set of edges, and the set of faces on the lattice. The toric code is defined to be the ground state of the Hamiltonian 
where operator X is the product of Pauli X operators on the qubits located on edges forming the vertex v, i.e., X, and X is the product of Pauli Z operators on the qubits located on edges of face f. The code space is spanned by the simultaneous ``+1'' eigenstate of all operators X and X. These operators, together with any possible product of them, are the stabilizers of the code, and form the stabilizer group. The torus' non-trivial cycles encodes the logical operators. Errors, below a certain threshold, will only introduce local effects and do not change these cycles.

For simplicity, we consider non-correlated noise caused by i.i.d. bit-flip errors, where each qubit is subjected to a Pauli X error with probability X. Due to lattice duality, the error detection and correction of phase-flip errors is identical. The phenomenological noise model adds noisy measurements with probability of error during each measurement equal to X. 

Error correction is proceeded by measuring a set of independent stabilizers of the code, i.e., the operators X and X. For a set of phase-flip errors X, the stabilizers X that anticommute with the error return a non-trivial outcome. The set of non-trivial eigenvalues of the stabilizers is called the syndrome X of the code. Given the measured X, it is the task of the decoder to find the correction operator X. When the correction operator is applied, the code is returned to the code space, i.e. X. The error is corrected up to a stabilizer. The mapping of measured syndrome to the correction is thus not one-to-one, and it is up to the decoder to choose the correction most similar to the error. 

Union-Find decoder

The Union-Find decoder [0] maps each element of the syndrome X to a so-called non-trivial vertex v in a non-connected graph on the code lattice, and grows clusters that form a connected graph X of vertices X and edges X locally, by repetitively adding a layer of edges and trivial vertices to existing clusters, until all clusters have an even number of non-trivial syndrome vertices. This process is described as the growth of a cluster or the growth of the vertices that lie on a cluster's boundary. Then, a spanning tree is built for each cluster, and leafs are conditionally peeled from the tree in a tail recursive breadth-first search until all non-trivial syndrome vertices are paired and linked by a path, which is the correcting operator X [0]. By growing the clusters of vertices in order of their sizes --- the number of vertices in the cluster --- the threshold is reported to increase from X to X for bit-flip noise in this Weighted Growth variant of the decoder.

The complexity of the Union-Find decoder is driven by the merging between clusters. For this, the algorithm uses the Union-Find or disjoint-set data structure [0]. The function X is used to travel in the cluster-tree --- a disjoint set of the vertices of the cluster --- from vertex v to the representative root element X, to indentify the cluster to which v belongs. When two vertices X are connected on a newly added edge X, X output the roots X. If X, which means that the two cluster-trees are not connected, the clusters are merged by X by pointing the root of one tree to another. Weighted Union is performed by pointing the smaller tree to the larger to reduce the cost of future calls to Find.
