\subsection{Node parity, delay and suspension}\label{sec:paritydelaysus}

The Node-Suspension data structure allows for the calculation of the node suspension of all nodes in a node-tree $\nset$ by two intermediate steps. In each step a depth-first-searches (DFS) of $\nset$ is applied, such that the calculation can be performed in linear time to the node-tree dimension. In the first DFS, we calculate for the \textbf{node parity} - the number of child syndrome-nodes of a node modulo 2 - $np$ via a tail recursive function, which is only dependant on the node parities of the children nodes $\{n_{\gamma,1}, ...\}$ of a node $n_\beta$:
\begin{equation}\label{eq:nodeparity}
np_\beta =
\begin{cases}
    \big( \sum_{n_\gamma} (1-np_\gamma) \big ) \bmod 2 \hspace{1em} | \hspace{1em} n_\beta \equiv sn_\beta \\
    1 - \big( \sum_{n_\gamma} (1-np_\gamma) \big ) \bmod 2 \hspace{1em} | \hspace{1em} n_\beta \equiv jn_\beta.
\end{cases} 
\end{equation}

In the second DFS, we calculate for the difference in node suspension $\delta ns$ of a node $n_\beta$ with its parent $n_\alpha$. We can choose an arbitrary \textbf{node delay} $nd$ for the root node such as $nd_r=0$ and add the difference $\delta ns$ during each step to obtain $nd$ for every node. This node delay of a node $n_\beta$ is only dependent on the node radii of itself $nr_\beta$ and its parent $nr_\alpha$, the length of node-tree edge $(n_\beta, n_\alpha)$ and its parity $np_\beta$. 
\begin{multline}\label{eq:delayequation}
    nd_\beta = nd_\alpha + \Bigg \lceil 2k_{inv}\bigg(\ceil{\frac{nr_\beta}{2}} - \floor{\frac{nr_\alpha + nr_\beta \bmod 2}{2}}\\
    - (-1)^{np_\beta}\abs{(n_\beta,n_\alpha)}\bigg) - (nr_\beta - nr_\alpha) \bmod 2 \Bigg \rceil
\end{multline}
Here, the \textbf{inverion factor} $k_{inv}$ is a constant that deals with the inversion of node parities in a node-tree during merges of clusters, detailed in Section \ref{sec:nodejoin}. 

\Figure[htb](topskip=0pt, botskip=0pt, midskip=0pt){tikzfigs/tikz-figure3.pdf}{Two depth-first searches on $\mathcal{N}$ to compute node parities (head recursively) and delays (tail recursively).\label{fig3}}

There is a final step in calculating the node suspension from the node delay, which are related by
\begin{equation}\label{eq:suspension}
    ns = nd - \max_{nd_i \in \nset} nd_i - nw, 
\end{equation}
where $nw$ is equal to the number of iterations a node has \textbf{waited} or has been suspended from growth. The maximum node delay can be maintained during the second DFS of the node-tree. The node suspension itself is calculated dynamically during the growth of the cluster. 

A single growth iteration, which is applied in the original UF decoder by adding half-edges to all boundary vertices of the cluster, is now replaced by another DFS of $\nset$. During this DFS, a node is conditionally bloomed - adding half-edges to the boundary vertices in the current node and adding 1 to the node radius $nr$ - if $ns$ is equal to zero. If not, add 1 to $nw$ and continue with the DFS. A subsequent growth iteration now does not require the two DFS related to the calcualtion of $np$ and $nd$, provided that no union between clusters has occured. The Node-Suspension data structure enables us to calculate the node suspension across multiple growth iterations based on a single calculation of the node parity and delay. When all $ns$ in $\nset$ are zero, all nodes are bloomed simultaenously within the same iteration. This process of reaching equal $ns$ or PMW in the cluster is called the \textbf{Balanced Bloom} of nodes. 

Note that we hadn't stated which node in $\nset$ should be the root node. In fact, any node in $\nset$ could have been picked as the root of the node-tree. This property, together with the constancy of $np$ and $nd$ in betwen cluster unions, allows us to define a set of rules for the merges of node-trees.  