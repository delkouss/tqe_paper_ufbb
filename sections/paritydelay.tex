\subsection{Node parity, delay and suspension}\label{sec:paritydelaysus}

The Node-Suspension data structure allows for the calculation of the node suspension of all nodes in a node-tree $\nset$ by two intermediate steps. In each step a depth-first-search (DFS) of $\nset$ is applied, such that the calculation can be performed in linear time to the node-tree dimension.

\Figure[b](topskip=0pt, botskip=0pt, midskip=0pt){tikzfigs/tikz-figure3.pdf}{Two depth-first searches on $\mathcal{N}$ to compute node parities (head recursively) and delays (tail recursively).\label{fig3}}

In the first DFS, we calculate for the \textbf{node parity} $np$ --- the number of descendant syndrome-nodes of a node modulo 2 --- via a tail recursive function, which is only dependent on the node parities of the children nodes of a node.
\begin{align}\label{eq:nodeparity}
    snp &= &\big( \sum_{\mathclap{n_\gamma \in \text{ children of } sn}} (1-np_\gamma) \big ) \bmod 2 \hspace{1em}  \\
    jnp &= 1 - &\big(\sum_{\mathclap{n_\gamma \in \text{ children of } jn}} (1-np_\gamma) \big) \bmod 2 \hspace{1em}
\end{align}

In the second DFS, we calculate for the difference in node suspension of a node $n_\beta$ with its parent $n_\alpha$; $\delta = ns_\beta - ns_\alpha$. We can choose an arbitrary \textbf{node delay} $nd$ --- the node suspension minus the maximum node suspension in the node-tree --- for the root node such as $nd_r=0$ and add the suspension difference $\delta$ during each step to obtain $nd$ for every node. This node delay of a node $n_\beta$ is only dependent on the node radii of itself and of its parent $n_\alpha$, the length of edge $(n_\beta, n_\alpha)$ and its parity $np_\beta$. 
\begin{multline}\label{eq:delayequation}
    nd_\beta = nd_\alpha + \Bigg \lceil 2k_{inv}\bigg(\ceil{nr_\beta} - \floor{nr_\alpha + nr_\beta \bmod 1}\\
    - (-1)^{np_\beta}\abs{(n_\beta,n_\alpha)}\bigg) - 2(nr_\beta - nr_\alpha) \bmod2 \Bigg \rceil
\end{multline}
Here, the \textbf{inversion factor} $k_{inv}$ is a constant that deals with the inversion of node parities in a node-tree during merges of clusters, explained in \ref{sec:nodejoin}. 

There is a final step in calculating the node suspension from the node delay, which are related by
\begin{equation}\label{eq:suspension}
    ns = nd - \max_{nd_i \in \nset} nd_i - nw, 
\end{equation}
where $nw$ is equal to the number of iterations a node has \textbf{waited} or has been suspended from growth. The maximum node delay can be maintained during the second DFS of the node-tree, and the node suspension itself is calculated during the DFS related to the growth of the cluster, such that this step is not counted towards the node suspension calculation. 

A single growth iteration, which is applied in the original UF decoder by adding half-edges to all boundary vertices of the cluster, is now replaced by another DFS of $\nset$. During this DFS, a node is conditionally grown -- adding half-edges to the boundary vertices in the current node and adding 1 to its radius $nr$ -- if $ns$ is equal to zero. If not, suspend the node growth, add 1 to $nw$ and continue with the DFS. A subsequent growth iteration now does not require the two DFS's related to the calculation of $np$ and $nd$, provided that no union between clusters has occurred. Hence, the Node-Suspension data structure enables us to calculate the node suspension across multiple growth iterations based on a single calculation of the node parity and delay. When all $ns$ in $\nset$ are zero, all nodes are bloomed simultanenously within the same iteration. 

Note that we hadn't stated which node in $\nset$ should be the root node. In fact, any node in $\nset$ could have been picked as the root of the node-tree. This property, together with the constancy of $np$ and $nd$ in between cluster unions, allows us to define a set of rules for the merging of node-trees.  