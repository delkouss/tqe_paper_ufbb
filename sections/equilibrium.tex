\subsection{Parity inversion}

A unfortunate effect of the Node-Suspension data structure, which we dub parity-inversion, causes a decrease in the performance of the algorithm as the lattice size is increased (see Figure \ref{threshold_ufbb}). We will demonstrate this effect through the example in Figure \ref{fig5}\emph{a}. Consider three instances of the node-tree of Figure \ref{fig0} $\nset_a, \nset_b, \nset_c$, positioned closely to each other on the lattice. Every node in all node-trees have radius 1, and the node suspension in $n_1$ in each node-tree is 2. Thus means that if $n_1$ is suspended for two growth iterations, such as in Figure \ref{fig1}, all nodes have the same PMW. However, in this example, the node-trees $\nset_a, \nset_b, \nset_c$ merge after 1 iteration. The merged cluster is odd, thus we recalculate the node parities and delays per the rules set in the previous section. Now, the parities in the partition of the node-tree containing the nodes of $\nset_b$ have been inverted , and the calculated node suspensions in this partition increases dramatically. 

If the next merging event occurs on the node with the increased node suspension, the matching weight may be increased compared to the original UF decoder. This defines a trade-off in the node suspension; a node must wait as many iterations as it is suspended to reach equal PMW in the node-tree, but after a parity-inversion the node suspension for previously prioritized nodes increase linearly with the number of iterations waited by the suspended nodes pre-inversion. As a comprimise, we redefine the node suspension as \textbf{half} the number of growth iterations needed for all nodes in the node-tree to reach equal PMW. This can be done in Equation \eqref{eq:delayequation} by setting $k_{inv}=0.5$.

Nevertheless, as more parity inversions occur, the maximum node suspension in the node-tree increases, and it becomes more and more unlikely for a cluster to actually reach zero node suspension in all nodes. The number of parity inversions is directly related to the number of merging events, and thus the size of the lattice. The performance to improve the heuristic for minimum weight matchings thus decreases for larger lattices. 

\Figure[htb](topskip=0pt, botskip=0pt, midskip=0pt){tikzfigs/tikz-figure5.pdf}{
    (a) The delay values $n_i.d$ and the equilibrium-states $(I:k_{eq}M)$ for 3 odd clusters $\{\nset_1, \nset_2, \nset_3\}$ of 3 nodes that grow and join into a size-9 cluster. (Top) Initially, parity and delay calculations  are performed with delay equation \eqref{eq:2ddelay} on each odd cluster which have equilibrium-states $(0:2)$, with delay $2$ in the middle node. (Middle) The clusters are grown, where the middle node is delayed, such that it's delay value decreases to $1$, and the clusters have equilibrium-states $(1:2)$. (Bottom) The clusters join to a single odd cluster, which is selected for growth. Hence, parity and delay calculation is performed again, and the equilibrium-state is $(0:4)$, thus requiring 4 growth iterations before equal potential matching weight is reached in all nodes.  (b) The same clusters, growths and joins, but now with delay equation \eqref{eq:delayequation} for $k_{eq} = 1/2$. With the equilibrium factor, $(k_{eq}M:k_{eq}M)$ can be reached in fewer growth iterations; e.g. after 1 round (middle), $(1:1)$ is reached. Also, after join to a single cluster (bottom), fewer iterations are needed (2 compared to 4 in Figure \ref{fig:kbloom}).\label{fig5}}