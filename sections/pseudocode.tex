\subsection{Pseudocode}\label{sec:pseudocode}
\begin{algorithm}[htb]
  \BlankLine
  \KwData{A graph $G=(V,E)$, and syndrome $\sigma \subseteq V$}
  \KwResult{Correction set $\m{C}$}
  \BlankLine
  Initialize cluster vertex-trees, node-trees and table \emph{Support}.\;\label{algo:B1a}
  Create the list $\m{L}$ of odd clusters.\;
  \While(){$\m{L}$ is not empty}{
    Initialize the fusion list $\m{F}$ as an empty list.\;\label{algo:B1b}
    \For(){cluster $\in\m{L}$ \label{algo:B2a}}{
      \For(){$n \in$ even sub-root list at node root $r$}{
        Apply DFS's to calculate node parities and delays (Equations \eqref{eq:nodeparity}, \eqref{eq:delayequation}) from $n$ to descendent nodes. Keep track of the largest value for $n_d$ encountered during the delay DFS.\;\label{algo:pdc}
      }
      Apply DFS from root $r$ to all descendents. At each node during the DFS, if $n_s=0$ (Equation \eqref{eq:suspension}), grow all boundary edges of vertices in the node a half-edge per the Union-Find decoder, such that grown edges are added to $\m{F}$, and apply $n_r=n_r+\nicefrac{1}{2}$. If $n_s\neq0$, apply $n_w=n_w+1$ and continue the DFS.\;\label{algo:grow}
    }
    \For(){edge $(u,v) \in \m{F}$\label{algo:B3a}}{
      \eIf(){$\codefunc{Find}(u)\neq\codefunc{Find}(v)$}{
        Merge vertex-trees by weighted \codefunc{Union}.\;
        \eIf(){$u \in n_v$ and $v \in n_v$\label{algo:joina}}{
          Merge node-trees by \codefunc{Join}.\;
        }(){
          Add $u$ to $n_v$ or $v$ to $n_u$.\;\label{algo:joinb}
        }
      }($u,v$ in same cluster.\label{algo:dfa}){
        Subtract 1 from $(u,v)$ in \emph{Support}.\;\label{algo:dfb}
      }
    }
    Update $\m{L}$ with odd clusters\; \label{algo:B3b}
  }
  Apply the peeling decoder \cite{delfosse2017linear}.\label{algo:B4a}
  \caption{Union-Find Node-Suspension decoder}\label{algo:ufbb}
\end{algorithm}

\Figure[hbt](topskip=0pt, botskip=0pt, midskip=0pt){tikzfigs/tikz-figure6.pdf}{The \emph{fragmentation} of node-tree $\pre{k-1}\omega$ into its ancester node-trees, where the prefix $k-1$ indicates the \emph{fragmentation generation}. In the \emph{partial fragmentation} $f_\omega$, $\pre{k-1}\omega$ is fragmented into an odd ancestor $\pre{k}\omega_0$ and even ancestor $\pre{k}\epsilon$. Subsequently in the partial fragmentation $f_\epsilon$, $\pre{k}\epsilon$ is fragmented to odd ancestors $\pre{k}\omega_{1}$ and $\pre{k}\omega_{2}$. With $\kappa=2$, each partial fragmentation is the opposite of a join operation between two node-trees. Futhermore, note that if $\abs{\vset_0} = \abs{\vset_1} = \abs{\vset_2}$, the vertex-tree sizes related to node trees $\pre{k}\omega_0, \pre{k}\omega_1, \pre{k}\omega_2$, each generation is the opposite of a growth iteration. \label{fig6}}

The full version of the algorithm we have described is given in Algorithm \ref{algo:ufbb}. Note that this pseudocode includes instructions that are shortened versions of the pseudocode of the Union-Find decoder \cite{delfosse2017almost}. This is done for clarity on the additions of the Node-Suspension data structure and protocols on top of the Union-Find pseudocode. The first block  of lines \ref{algo:B1a}-\ref{algo:B1b} initializes the clusters and describes the loop of cluster growth. Block 2 contains lines \ref{algo:B2a}-\ref{algo:grow} and describes the DFS's related to the calculation of node parities and delays from all even sub-roots stored at the root node, and the DFS of the cluster growth. Block 3 contains lines \ref{algo:B3a}-\ref{algo:B3b} and describes the combined merging protocols of the Union-Find and Node-Suspension data structures. Node that lines \ref{algo:dfa}-\ref{algo:dfb} contain an extra step to ensure that the vertex-trees are always acyclic. The final block in line \ref{algo:B4a} is the peeling decoder \cite{delfosse2017linear}, which now does not have to create the spanning forest of the grown clusters. Similarly to the Union-Find decoder, Weighted Growth is applied such that the smallers cluster is always grown first. 
