\section{Performance}\label{sec:performance}

We benchmark the performance of our own variants of the Union-Find decoder, as well as the Union-Find Node-Suspension (UFNS) decoder of Algorithm \ref{algo:ufbb}. Decoding rate $k_d$ for a given lattice size and physical error rate are acquired by Monte Carlo simulations. We apply the error model of \ref{sec:errormodel} of only i.i.d. phase-flip errors with chance $p_Z$ , which is \textbf{independent noise}. Additionaly, we compare the performance for \textbf{phenomonological noise}, which adds faulty syndrome measurements occuring at chance $p_Z$. Code thresholds $p_{th}$ are obtained by curve fitting for the crossing point of $k_d$-lines over a range of physical error rates of a range of lattice sizes. We also use the decoding succes rate at the threshold $k_d(p_{th})= k_{th}$ as a metric to compare decoders. 

\subsection{Union-Find decoder variants}

We show that $p_{th}$ can be increased and the matching weight $\abs{\m{C}}$ can be decreased within the Union-Find decoder with some previously introduced concept \textbf{without} the Node-Suspension data structure. We compare distinct variants of our implementation of the Union-Find decoder, that either implements Weighted Growth via bucket sort or no Weighted Growth, and either constructs aclycic vertex-trees post-growth or maintains thems during cluster growth. The latter is achived by applying lines \ref{algo:dfa}-\ref{algo:dfb} of Algorithm \ref{algo:ufbb} in the UF decoder. The labels for each variant are listed in Table \ref{tab:uftable}.

\begin{table}[htbp]
  \centering
  \begin{tabularx}{\linewidth} { | R{1.2} || C{0.9} | C{0.9} | }
    \hline
    & Vertex-tree \textbf{A}fter growth &  Vertex-tree \textbf{D}uring growth \\
    \hhline{|=::=:=|}
    No WG & AUF  & DUF \\
    \hline
    \textbf{B}ucket sort WG & BAUF & BDUF \\
    \hline
  \end{tabularx}
  \caption{Abbreviated names for the variants of the Union-Find decoder.}\label{tab:uftable}
\end{table}

The thresholds $p_{th}$ and $k_{th}$ for each variant, including for the Minimum-Weight Perfect Matching (MWPM) decoder, are listed in Table \ref{tab:ufndfwug}. Weighted Growth has the expected behavior of increasing $p_{th}$. Maintaining vertex-trees during growth is equivalent to multiple breadth-first searches (BFS's) from each non-trivial vertex within the cluster, and provides a slight increase in $p_{th}$, but a more significant increase in $k_{th}$. We suspect that the BFS tree has shorter branches in between junctions, which leads to a deceased matching weight and increased $k_{th}$. We plot the matching weight $\abs{\m{C}}$ of the UF variants, normalized to the minimum weight of the MWPM decoder for $p_Z = 0.098$ in Figure \ref{comp_weight}. Here we see a correlation between a decrease in $\abs{\m{C}}$ with an increase in performance: both Weighted Growth and maintaining acyclic vertex-trees during growth increases the performance and decreases the matching weight. 

\begin{table}[htbp]
  \centering
  \begin{tabularx}{\linewidth} { | R{1} || C{1} | C{1} | C{1} | C{1} | }
    \hline
    \multirow{2}{*}{} & \multicolumn{2}{c|}{Independent}& \multicolumn{2}{c|}{Phenomenological} \\
    \cline{2-5}
     & $p_{th}$ & $k_{th}$ & $p_{th}$ & $k_{th}$ \\
    \hhline{|=::=:=:=:=|}
    AUF & $9.72\%$ & $73.34\%$ & $ 2.53\%$ & $92.39\%$ \\
    \hline
    DUF & $9.79\%$ & $74.32\%$ & $2.56\%$ & $93.64\%$ \\
    \hline
    BAUF & $9.98\%$ & $72.71\%$ & $2.68\%$ & $91.32\%$ \\
    \hline
    BDUF & $10.01\%$ & $72.86\%$ & $2.69\%$ & $92.08\%$ \\
    \hline
    MWPM & $10.35\%$ & $71.58\%$ & $2.97\%$ & $90.24\%$\\
    \hline
  \end{tabularx}
  \caption{Threshold error rates $p_{th}$ and threshold decoding success rates $k_{th}$ for the implementations of the  Union-Find decoder of Table \ref{tab:uftable}.}\label{tab:ufndfwug}
\end{table}
\Figure[htb](topskip=0pt, botskip=0pt, midskip=0pt){tikzfigs/comp_matching_weight.pdf}{
  The matching weight $\abs{\m{C}}$ of the Union-Find decoder variants (Table \ref{tab:uftable}) and the UFNS decoder, normalized to the minimum weight $\min{\abs{\m{C}}}$ obtained via the Minimum-Weight Perfect Matching decoder. All weights are obtained by Monte Carlo simulations on $p_Z=0.098$ with a minimum of $100.000$ samples. The x-axis scales linearly with $N = L^2$. \label{comp_weight}}

\subsection{Union-Find Node-Suspension decoder}

\Figure[htb](topskip=0pt, botskip=0pt, midskip=0pt){tikzfigs/threshold_ufbb.pdf}{
  The decoding rates $k_d$ of (a) the UFNS decoder and (c) the BDUF and MWPM decoders, obtained via Monte Carlo simulations with a minimum of 100.000 samples per lattice size per error rate. (a) The $k_d$ lines of the UFNS decoder do not cross in a single point, such that there is not obvious code threshold. (b) The crossing point of $k_d$ lines of subsequent lattice sizes are the so-called threshold coordinates, which follow a trend in $(p_Z, k_d)$ space as the lattice sizes increase. (c) The threshold coordinates of the UFNS decoder occupy the region in $(p_Z, k_d)$ space of the MWPM decoder. \label{threshold_ufbb}}

We benchmark the performance of the Union-Find Node-Suspension (UFNS) decoder of Algorithm \ref{algo:ufbb}, and plot the $k_d$ lines in Figure \ref{threshold_ufbb}\emph{a}. We find that the $k_d$ lines of the UFNS decoder do not cross in a single point, such that there is no clear threshold $p_{th}$. In fact, the intersections of $k_d$ lines of subsequent lattices sizes, which we dub threshold coordinates, follow a trend where an increase in the input lattice sizes results in a decrease in $p_{th}$ but increase in $k_{th}$. We ascribe the degradation of the threshold error rate to the \emph{parity inversion} effect. These threshold coordinates $(p_{th}, k_{th})$ are plotted in Figure \ref{threshold_ufbb}\emph{b}. When these coordinates are plotted together with the $k_d$ lines of the BDUF and MWPM decoders, such as in Figure \ref{threshold_ufbb}\emph{c}, we see that the threshold coordinate for small lattice sizes is similar to the MWPM threshold coordinate. For larger lattice sizes, UFNS threshold coordinates move towards the BDUF threshold on the $p_Z$ axis, but still has an increased performance due on the increased $k_{th}$. Overall, the threshold coordinates occupy a region in $(p_Z, k_d)$ space that was previously reserved to the MWPM decoder. 

\Figure[htb](topskip=0pt, botskip=0pt, midskip=0pt){tikzfigs/comp_time.pdf}{
  The mean computation time of the UFNS, BDUF and MWPM decoders. All weights are obtained by Monte Carlo simulations on $p_Z=0.098$ with a minimum of $100.000$ samples. The x-axis scales linearly with $N = L^2$.\label{comp_time}}

The matching weight $\abs{\m{C}}$ of the UFNS decoder is successfully further decreased compared to all UF variants of Table \ref{tab:uftable}. For $p_Z = 0.098$ the normalized matching weight is halved compared to the BDUF decoder (Figure \ref{comp_weight}). Finally, we compare the average running time of Monte Carlo simulations to obtain matchings between the UFNS, BDUF and MWPM decoders. The comparison for $p_Z=0.098$ is included in Figure \ref{comp_time}. The average running time of UFNS, while behaving according to the worst-case complexity of $\m{O}(N \log{N})$, is also not linear. However, The UFNS decoder does offer a midway choice between the MWPM decoder and DBUF decoder. 

\Figure[htb](topskip=0pt, botskip=0pt, midskip=0pt){tikzfigs/comp_lowerror.pdf}{
  The decoding rate $k_d$ for the low error regime of phenomonological noise for the MWPM, UFNS, BDUF and AUF decoders. The UFNS decoding rates are improved from the UF variants, and is very similar to MWPM. \label{comp_lowerror}}


\par

The simulator for the surface code, the Union-Find decoder variants and the Union-Find Node-Suspension decoder have all been implemented in Python using our application \cite{OpenSurfaceSim}. The MWPM decoder utilitizes the C implementation of BlossomV \cite{kolmogorov2009blossom} due to substantial slow perfomances of Python implementations. Simulations were initially performed on a single 3.20 GHz Intel Core i5 CPU, but later parallelized on all 24 threads of 3.60 GHz Intel Xeon E5 CPU's. 