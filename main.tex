\documentclass{ieeeaccess}
\usepackage[OT1]{fontenc} 
\usepackage{amsfonts, amsmath, amssymb, amsthm}
\usepackage{algorithmic}
\usepackage{graphicx}
\usepackage{caption}
\usepackage{placeins}
% \DeclareCaptionFont{ieeeblue}{\color{accessblue}}
% \DeclareCaptionLabelFormat{myformat}{\figcapfont{\textbf{#1}\textbf{#2}}}
% \captionsetup{labelfont={bf,ieeeblue},labelformat=myformat}
\usepackage{setspace}
\usepackage[font={sf,scriptsize,stretch=0.84}, labelfont={bf,color=accessblue}]{caption}

\usepackage{tabularx, hhline, multirow}
\newcolumntype{L}[1]{>{\hsize=#1\hsize\raggedright\arraybackslash}X}%
\newcolumntype{R}[1]{>{\hsize=#1\hsize\raggedleft\arraybackslash}X}%
\newcolumntype{C}[1]{>{\hsize=#1\hsize\centering\arraybackslash}X}%
\newcommand{\gc}{\cellcolor[gray]{0.9}}

\usepackage{enumitem}
\usepackage{textcomp}
\usepackage{nicefrac}
\usepackage{mathtools}
\DeclarePairedDelimiter{\abs}{\lvert}{\rvert}
% \def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
%     T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}
\usepackage[style=ieee, sorting=none]{biblatex}
\addbibresource{cit.bib}

% \usepackage[table]{xcolor}
% % Define colors

\newtheorem{definition}{Definition}[section]
\newtheorem{lemma}{Lemma}[section]
\newtheorem{theorem}{Theorem}[section]
\newtheorem{proposition}{Proposition}[section]

% Set new commands
\newcommand{\codeword}[1]{\texttt{\textcolor{MidnightBlue}{#1}}}
%\newcommand{\codefunc}[1]{\texttt{\textcolor{OliveGreen}{#1}}}
\let\oldemptyset\emptyset
\let\emptyset\varnothing
\newcommand{\codefunc}[1]{\texttt{#1}}
\newcommand{\m}[1]{\mathcal{#1}}
\newcommand{\n}[1]{\mathscr{#1}}
\newcommand{\bound}{\mathscr{B}}
\newcommand{\akker}{\mathscr{A}}
\newcommand{\nset}{\mathcal{N}}
\newcommand{\vset}{\mathcal{V}}
\newcommand{\pre}[1]{ {}^{#1} }
\newcommand{\ceil}[1]{{\left \lceil #1 \right \rceil }}
\newcommand{\floor}[1]{{\left \lfloor #1 \right \rfloor }}

% Set algorithm2e package settings
\usepackage[linesnumbered, ruled, vlined]{algorithm2e}
\SetAlgoCaptionLayout{centerline}
\setlength{\algoheightrule}{1pt}
\setlength{\algotitleheightrule}{1pt}
\setlength{\interspacetitleboxruled}{.5em}
\SetStartEndCondition{ }{}{}
\SetKwProg{Fn}{def}{\string:}{}
\SetKw{KwTo}{in}
\SetKwFor{For}{for}{\string:}{}
\SetKwIF{If}{ElseIf}{Else}{if}{ then}{else if}{else}{}
\SetKwFor{While}{while}{ do}{}
\SetInd{0.1em}{0.5em}
\SetAlgoNoEnd\DontPrintSemicolon
\SetAlFnt{\small}


\begin{document}
\history{Date of publication xxxx 00, 0000, date of current version xxxx 00, 0000.}
\doi{10.1109/TQE.2020.DOI}

\title{Quasilinear Time Decoding Algorithm for \\Topological Codes with High Error Threshold}
\author{
    \uppercase{S. Hu}\authorrefmark{1},
    \uppercase{and D. Elkouss\authorrefmark{2}}
}
\address[1]{Department of Physics, Delft University of Technology (email: watermarkhu@outlook.com)}
\address[2]{QuTech, Delft University of Technology, Lorentzweg 1
2628CJ Delft, The Netherlands (email: d.elkousscoronas@qutech.nl)}

\tfootnote{This work was partially supported by the Netherlands Organization for Scientific Research (NWO/OCW), as part of the Quantum Software Consortium program (project number 024.003.037/3368). }

\markboth
{S. Hu \headeretal: IEEE Transactions on Quantum Engineering}
{S. Hu \headeretal: IEEE Transactions on Quantum Engineering}

\corresp{Corresponding author: First A. Author (email: author@ boulder.nist.gov).}

\begin{abstract}
    Quantum computing has the potential to transcend the information technology as we know it. Small scale quantum systems are already possible today, and the goal is to scale up these quantum architectures to build practical quantum devices. A major limiting factor in quantum computing is the accumulation of errors that may be caused by various sources. A solution is to encode the logical information in a larger amount of physical qubits to increase resilience and to decode the information with a decoder. 
    
    We introduce a modification of the Union-Find decoder that aims to further decrease the weight of the correction operator, similarly to the Minimum-Weight Perfect Matching decoder. The modified decoder, dubbed the Union-Find Balanced-Bloom decoder, manages to have an increased error threshold compared to the Union-Find decoder of any lattice size. For small lattice sizes, the Union-Find Balanced-Bloom decoder performs near the code threshold of the Minimum-Weight Matching decoder. We manage to maintain a quasilinear worst-case time complexity of $\m{O}(N\log{N})$. 
\end{abstract}

\begin{keywords}
    Quantum Computing, Quantum Error Correction, Surface Code
\end{keywords}

\titlepgskip=-15pt
\maketitle

\input{sections/introduction}
\input{sections/surfacecode}
\input{sections/unionfind}
\input{sections/ufbb}
\input{sections/matchingweight}
\input{sections/nodeset}
\input{sections/paritydelay}
\input{sections/nodejoin}
\input{sections/inversion}
\input{sections/pseudocode}
\input{sections/complexity}
\input{sections/performance}
\input{sections/conclusion}

\FloatBarrier
\printbibliography
\EOD
\end{document}