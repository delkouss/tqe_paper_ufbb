\documentclass{ieeeaccess}
\usepackage[OT1]{fontenc} 
\usepackage{amsfonts, amsmath, amssymb, amsthm}
\usepackage{algorithmic}
\usepackage{graphicx}
\usepackage{caption}
\usepackage{placeins}
% \DeclareCaptionFont{ieeeblue}{\color{accessblue}}
% \DeclareCaptionLabelFormat{myformat}{\figcapfont{\textbf{#1}\textbf{#2}}}
% \captionsetup{labelfont={bf,ieeeblue},labelformat=myformat}z
\usepackage{setspace}
\usepackage[font={sf,scriptsize,stretch=0.84}, labelfont={bf,color=accessblue}]{caption}

\usepackage{tabularx, hhline, multirow}
\newcolumntype{L}[1]{>{\hsize=#1\hsize\raggedright\arraybackslash}X}%
\newcolumntype{R}[1]{>{\hsize=#1\hsize\raggedleft\arraybackslash}X}%
\newcolumntype{C}[1]{>{\hsize=#1\hsize\centering\arraybackslash}X}%
\newcommand{\gc}{\cellcolor[gray]{0.9}}

\usepackage{enumitem}
\usepackage{textcomp}
\usepackage{cleveref}
\usepackage{nicefrac}
\usepackage{mathtools}
\DeclarePairedDelimiter{\abs}{\lvert}{\rvert}
% \def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
%     T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}
\usepackage[style=ieee, sorting=none]{biblatex}
\addbibresource{citations/*.bib}

% \usepackage[table]{xcolor}
% % Define colors

\newtheorem{definition}{Definition}[section]
\newtheorem{lemma}{Lemma}[section]
\newtheorem{theorem}{Theorem}[section]
\newtheorem{proposition}{Proposition}[section]

% Set new commands
\newcommand{\codeword}[1]{\texttt{\textcolor{MidnightBlue}{#1}}}
%\newcommand{\codefunc}[1]{\texttt{\textcolor{OliveGreen}{#1}}}
\let\oldemptyset\emptyset
\let\emptyset\varnothing
\newcommand{\codefunc}[1]{\texttt{#1}}
\newcommand{\m}[1]{\mathcal{#1}}
\newcommand{\n}[1]{\mathscr{#1}}
\newcommand{\bound}{\mathscr{B}}
\newcommand{\akker}{\mathscr{A}}
\newcommand{\nset}{\mathcal{N}}
\newcommand{\vset}{\mathcal{V}}
\newcommand{\pre}[1]{ {}^{#1} }
\newcommand{\ceil}[1]{{\left \lceil #1 \right \rceil }}
\newcommand{\floor}[1]{{\left \lfloor #1 \right \rfloor }}

% Set algorithm2e package settings
\usepackage[linesnumbered, ruled, vlined]{algorithm2e}
\SetAlgoCaptionLayout{centerline}
\setlength{\algoheightrule}{1pt}
\setlength{\algotitleheightrule}{1pt}
\setlength{\interspacetitleboxruled}{.5em}
\SetStartEndCondition{ }{}{}
\SetKwProg{Fn}{def}{\string:}{}
\SetKw{KwTo}{in}
\SetKwFor{For}{for}{\string:}{}
\SetKwIF{If}{ElseIf}{Else}{if}{ then}{else if}{else}{}
\SetKwFor{While}{while}{ do}{}
\SetInd{0.1em}{0.5em}
\SetAlgoNoEnd\DontPrintSemicolon
\SetAlFnt{\small}


\begin{document}
\history{Date of publication xxxx 00, 0000, date of current version xxxx 00, 0000.}
\doi{10.1109/TQE.2020.DOI}

\title{Quasilinear Time Decoding Algorithm for \\Topological Codes with High Error Threshold}
\author{
    \uppercase{S. Hu}\authorrefmark{1},
    \uppercase{and D. Elkouss\authorrefmark{2}}
}
\address[1]{Department of Physics, Delft University of Technology (email: watermarkhu@outlook.com)}
\address[2]{QuTech, Delft University of Technology, Lorentzweg 1
2628CJ Delft, The Netherlands (email: d.elkousscoronas@qutech.nl)}

\tfootnote{This work was partially supported by the Netherlands Organization for Scientific Research (NWO/OCW), as part of the Quantum Software Consortium program (project number 024.003.037/3368), and the Unitary Fund.}

\markboth
{S. Hu \headeretal: IEEE Transactions on Quantum Engineering}
{S. Hu \headeretal: IEEE Transactions on Quantum Engineering}

\corresp{Corresponding author: First A. Author (email: author@ boulder.nist.gov).}

\begin{abstract}
    Quantum computing has the potential to transcend the information technology as we know it. Small scale quantum systems are already possible today, and the goal is to scale up these quantum architectures to build practical quantum devices. A major limiting factor in quantum computing is the accumulation of errors that may be caused by various sources. A solution is to encode the logical information in a larger amount of physical qubits to increase resilience, thereafter to decode the information with a decoder. A recently proposed decoder dubbed the Union-Find (UF) decoder is fast and almost linear in its worst-case time complexity but has a reduced perfomance compared with the Minimum-Weight Perfect Matching (MWPM) decoder. We propose a modification of the UF decoder that aims to further decrease the weight of the correction operator, similarly to the MWPM decoder. The modified decoder, dubbed the Union-Find Node-Suspension (UFNS) decoder, manages to have an improved performance compared to the UF decoder of any lattice size. For small lattice sizes and also for low error rates, the UFNS decoder performs near identically to the MWPM decoder. We manage to maintain a quasilinear worst-case time complexity of $\m{O}(n\log{n})$. 
\end{abstract}

\begin{keywords}
    Quantum Computing, Quantum Error Correction, Surface Code
\end{keywords}

\titlepgskip=-15pt
\maketitle

\input{sections/introduction}
\input{sections/ufbb}
\input{sections/pseudocode}
\input{sections/complexity}
\input{sections/performance}
\input{sections/conclusion}

\FloatBarrier
\printbibliography
\EOD
\end{document}